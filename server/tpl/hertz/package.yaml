layouts:
  - path: handler.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package {{.PackageName}}
      import (
          "context"

          "github.com/cloudwego/hertz/pkg/app"
          "github.com/cloudwego/hertz/pkg/protocol/consts"
      
      {{- range $k, $v := .Imports}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
          "{{$.ProjPackage}}/utils/httputil"
      )
      {{range $_, $MethodInfo := .Methods}}
      {{$MethodInfo.Comment}}
      func {{$MethodInfo.Name}}(ctx context.Context, c *app.RequestContext) {
          var err error
          {{if ne $MethodInfo.RequestTypeName "" -}}
          var req {{$MethodInfo.RequestTypeName}}
          resp := new({{$MethodInfo.ReturnTypeName}})
          err = c.BindAndValidate(&req)
          if err != nil {
             resp.Code = -1
             resp.Message = err.Error()
             httputil.SendResponse(ctx, c, consts.StatusBadRequest, resp)
             return
          }
          {{end}}
          // add your logic here
          httputil.SendResponse(ctx, c, consts.StatusOK, resp)
      }
      {{end}}
  - path: handler_single.go
    body: |+
      {{.Comment}}
      func {{.Name}}(ctx context.Context, c *app.RequestContext) {
         var err error
         {{if ne .RequestTypeName "" -}}
         var req {{.RequestTypeName}}
         resp := new({{.ReturnTypeName}})
         err = c.BindAndValidate(&req)
         if err != nil {
            resp.Code = -1
            resp.Msg = err.Error()
            httputil.SendResponse(ctx, c, consts.StatusBadRequest, resp)
            return
         }
         {{end}}
         // add your logic here
         httputil.SendResponse(ctx, c, consts.StatusOK, resp)
      }
  - path: "utils/httputil/resp.go"
    body: |-
      package httputil

      import (
          "context"

          "github.com/cloudwego/hertz/pkg/app"         
        
          "{{.GoModule}}/utils/bytesconv"
      )

      func SendResponse(ctx context.Context, c *app.RequestContext, code int, resp interface{}) {
          if bytesconv.B2s(c.ContentType()) == "application/x-protobuf" {
              c.ProtoBuf(code, resp)
          } else {
              c.JSON(code, resp)
          }
      }
  - path: "utils/bytesconv/bytesconv.go"
    body: |-
      package bytesconv

      import (
          "reflect"
          "unsafe"
      )

      // B2s converts byte slice to a string without memory allocation.
      // See https://groups.google.com/forum/#!msg/Golang-Nuts/ENgbUzYvCuU/90yGx7GUAgAJ .
      //
      // Note it may break if string and/or slice header will change
      // in the future go versions.
      func B2s(b []byte) string {
          /* #nosec G103 */
          return *(*string)(unsafe.Pointer(&b))
      }
        
      // S2b converts string to a byte slice without memory allocation.
      //
      // Note it may break if string and/or slice header will change
      // in the future go versions.
      func S2b(s string) (b []byte) {
          /* #nosec G103 */
          bh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
          /* #nosec G103 */
          sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
          bh.Data = sh.Data
          bh.Len = sh.Len
          bh.Cap = sh.Len
          return b
      }