layouts:
  - path: handler.go
    delims:
      - "{{"
      - "}}"
    body: |-
      {{$OutDirs := GetUniqueHandlerOutDir .Methods}}
      package {{.PackageName}}
      import (
          "context"

          "github.com/cloudwego/hertz/pkg/app"
          "github.com/cloudwego/hertz/pkg/protocol/consts"
      
      {{- range $k, $v := .Imports}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
      {{- range $_, $OutDir := $OutDirs}}
          {{if eq $OutDir "" -}}
          "{{$.ProjPackage}}/biz/service"
          {{- else -}}
          "{{$.ProjPackage}}/biz/service/{{$OutDir}}"
          {{- end -}}
      {{- end}}
          "{{$.ProjPackage}}/pkg/httputil"
      )
      {{range $_, $MethodInfo := .Methods}}
      {{$MethodInfo.Comment}}
      func {{$MethodInfo.Name}}(ctx context.Context, c *app.RequestContext) {
          var req {{$MethodInfo.RequestTypeName}}
          resp := new({{$MethodInfo.ReturnTypeName}})
          if err := c.BindAndValidate(&req); err != nil {
              resp.Code = -1
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, consts.StatusBadRequest, resp)
              return
          }
          {{if eq $MethodInfo.OutputDir "" -}}
          err := service.New{{$MethodInfo.Name}}Service(ctx, c).Run(&req, resp)
          {{else}}
          err := {{$MethodInfo.OutputDir}}.New{{$MethodInfo.Name}}Service(ctx, c).Run(&req, resp)
          {{end}}
          if err != nil {
              resp.Code = int32(err.ErrCode())
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, err.StatusCode(), resp)
              return
          }
          httputil.SendResponse(ctx, c, consts.StatusOK, resp)
      }
      {{end}}
    update_behavior:
      import_tpl:
        - |-
          {{$OutDirs := GetUniqueHandlerOutDir .Methods}}
          {{- range $_, $OutDir := $OutDirs}}
            {{if eq $OutDir "" -}}
              "{{$.ProjPackage}}/biz/service"
            {{- else -}}
              "{{$.ProjPackage}}/biz/service/{{$OutDir}}"
            {{end}}
          {{- end}}
  - path: handler_single.go
    body: |+
      {{.Comment}}
      func {{.Name}}(ctx context.Context, c *app.RequestContext) {
          {{if ne .RequestTypeName "" -}}
          var req {{.RequestTypeName}}
          resp := new({{.ReturnTypeName}})
          if err := c.BindAndValidate(&req); err != nil {
              resp.Code = -1
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, consts.StatusBadRequest, resp)
              return
          }
          {{end}}
          {{if eq .OutputDir "" -}}
          err := service.New{{.Name}}Service(ctx, c).Run(&req, resp)
          {{else}}
          err := {{.OutputDir}}.New{{.Name}}Service(ctx, c).Run(&req, resp)
          {{end}}
          if err != nil {
              resp.Code = int32(err.ErrCode())
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, err.StatusCode(), resp)
              return
          }
          httputil.SendResponse(ctx, c, consts.StatusOK, resp)
      }
  - path: "pkg/errno/errno.go"
    update_behavior:
      type: "skip"
    body: |-
      package errno

      import (
      	"bytes"
      	"errors"
      	"net/http"
      	"runtime"
      	"strconv"
      )

      type Err struct {
      	err        error
      	errCode    int
      	statusCode int

      	pcs        []uintptr
      	stackTrace string
      }

      func (e *Err) Error() string {
      	return e.err.Error()
      }

      func (e *Err) Unwrap() error {
      	return e.err
      }

      func (e *Err) StatusCode() int {
      	return e.statusCode
      }

      func (e *Err) ErrCode() int {
      	return e.errCode
      }

      func (e *Err) SetErrCode(errCode int) *Err {
      	e.errCode = errCode
      	return e
      }

      func (e *Err) StackTrace() string {
      	if len(e.stackTrace) != 0 {
      		return e.stackTrace
      	}
      	buf := bytes.NewBufferString("Stack Trace:")
      	if len(e.pcs) != 0 {
      		frame := runtime.CallersFrames(e.pcs)
      		for {
      			frame, more := frame.Next()
      			if !more {
      				break
      			}
      			buf.WriteByte('\n')
      			buf.WriteString(frame.Function)
      			buf.WriteByte('\n')
      			buf.WriteByte('\t')
      			buf.WriteString(frame.File)
      			buf.WriteByte(':')
      			buf.WriteString(strconv.Itoa(frame.Line))
      		}
      	}
      	if ierr, ok := e.err.(interface{ StackTrace() string }); ok {
      		buf.WriteByte('\n')
      		buf.WriteString(ierr.StackTrace())
      	} else if ierr, ok := e.err.(*Err); ok {
      		buf.WriteByte('\n')
      		buf.WriteString(ierr.StackTrace())
      	}
      	e.stackTrace = buf.String()
      	return e.stackTrace
      }

      func ToInternalErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusInternalServerError, pcs: callers(), errCode: -1}
      }

      func NewInternalErr(msg string) *Err {
      	return ToInternalErr(errors.New(msg))
      }

      func ToValidationErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusBadRequest, pcs: callers(), errCode: -1}
      }

      func NewValidationErr(msg string) *Err {
      	return ToValidationErr(errors.New(msg))
      }

      func ToPermissionErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusForbidden, pcs: callers(), errCode: -1}
      }

      func NewPermissionErr(msg string) *Err {
      	return ToPermissionErr(errors.New(msg))
      }

      func ToNotFoundErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusNotFound, pcs: callers(), errCode: -1}
      }

      func NewNotFoundErr(msg string) *Err {
      	return ToNotFoundErr(errors.New(msg))
      }

      func ToAuthenticationErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusUnauthorized, pcs: callers(), errCode: -1}
      }

      func NewAuthenticationErr(msg string) *Err {
      	return ToAuthenticationErr(errors.New(msg))
      }

      func ToDependencyErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusFailedDependency, pcs: callers(), errCode: -1}
      }

      func NewDependencyErr(msg string) *Err {
      	return ToDependencyErr(errors.New(msg))
      }

      func callers() []uintptr {
      	var pcs [64]uintptr
      	n := runtime.Callers(3, pcs[:])
      	return pcs[:n]
      }

  - path: "pkg/httputil/resp.go"
    update_behavior:
      type: "skip"
    body: |-
      package httputil

      import (
          "context"

          "github.com/cloudwego/hertz/pkg/app"         
        
          "{{.GoModule}}/pkg/bytesconv"
      )

      func SendResponse(ctx context.Context, c *app.RequestContext, code int, resp any) {
          if bytesconv.B2s(c.ContentType()) == "application/x-protobuf" {
              c.ProtoBuf(code, resp)
          } else {
              c.JSON(code, resp)
          }
      }
  - path: "pkg/bytesconv/bytesconv.go"
    update_behavior:
      type: "skip"
    body: |-
      package bytesconv

      import (
          "reflect"
          "unsafe"
      )

      // B2s converts byte slice to a string without memory allocation.
      // See https://groups.google.com/forum/#!msg/Golang-Nuts/ENgbUzYvCuU/90yGx7GUAgAJ .
      //
      // Note it may break if string and/or slice header will change
      // in the future go versions.
      func B2s(b []byte) string {
          /* #nosec G103 */
          return *(*string)(unsafe.Pointer(&b))
      }
        
      // S2b converts string to a byte slice without memory allocation.
      //
      // Note it may break if string and/or slice header will change
      // in the future go versions.
      func S2b(s string) (b []byte) {
          /* #nosec G103 */
          bh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
          /* #nosec G103 */
          sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
          bh.Data = sh.Data
          bh.Len = sh.Len
          bh.Cap = sh.Len
          return b
      }

  - path: "biz/service/{{.HandlerGenPath}}/{{ToSnakeCase .MethodName}}.go"
    loop_method: true
    update_behavior:
      type: "skip"
    body: |-
      package {{.FilePackage}}
      import (
          "context"
          "github.com/cloudwego/hertz/pkg/app"
      {{- range $k, $v := .Models}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
          "meetplan/pkg/errno"
      )
      type {{.Name}}Service struct {
          RequestContext  *app.RequestContext
          Context         context.Context
      }
      
      func New{{.Name}}Service(ctx context.Context, RequestContext *app.RequestContext) *{{.Name}}Service {
          return &{{.Name}}Service{RequestContext: RequestContext, Context: ctx}
      }
      
      // Run req should not be nil and resp should not be nil
      func (h *{{.Name}}Service) Run(req *{{.RequestTypeName}}, resp *{{.ReturnTypeName}}) (err *errno.Err) {
          if resp == nil{
              resp = new(model.CreateFriendLinkResponse)
          }
          //defer func() {
          // hlog.CtxInfof(h.Context, "req = %+v", req)
          // hlog.CtxInfof(h.Context, "resp = %+v", resp)
          //}()
          // todo edit your code
          return
      }
  - path: "biz/service/{{.HandlerGenPath}}/{{ToSnakeCase .MethodName}}_test.go"
    loop_method: true
    update_behavior:
      type: "skip"
    body: |-
      package {{.FilePackage}}
      import (
          "context"
          "testing"
          "github.com/cloudwego/hertz/pkg/app"
          "github.com/cloudwego/hertz/pkg/common/test/assert"
      {{- range $k, $v := .Models}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
      )
      func Test{{.Name}}Service_Run(t *testing.T) {
          ctx := context.Background()
          c := app.NewContext(1)
          s := New{{.Name}}Service(ctx, c)
          // init req and assert value
          req := &{{.RequestTypeName}}{}
          resp := &{{.ReturnTypeName}}{}
          err := s.Run(req, resp)
          assert.DeepEqual(t, nil, resp)
          assert.DeepEqual(t, nil, err)
          // todo edit your unit test.
      }
  - path: "{{.HandlerDir}}/{{.GenPackage}}/{{ToSnakeCase .ServiceName}}_test.go"
    loop_service: true
    update_behavior:
      type: "append"
      append_key: "method"
      insert_key: "Test{{$.Name}}"
      append_tpl: |-
        func Test{{.Name}}(t *testing.T) {
            h := server.Default()
            h.GET("{{.Path}}", {{.Name}})
            w := ut.PerformRequest(h.Engine, "{{.HTTPMethod}}", "{{.Path}}", &ut.Body{Body: bytes.NewBufferString(""), Len: 1},
            ut.Header{})
            resp := w.Result()
            assert.DeepEqual(t, 201, resp.StatusCode())
            assert.DeepEqual(t, "", string(resp.Body()))
            // todo edit your unit test.
        }
    body: |-
      package {{.FilePackage}}
      import (
          "bytes"
          "testing"
          "github.com/cloudwego/hertz/pkg/app/server"
          "github.com/cloudwego/hertz/pkg/common/test/assert"
          "github.com/cloudwego/hertz/pkg/common/ut"
      )
      {{range $_, $MethodInfo := $.Methods}}
      func Test{{$MethodInfo.Name}}(t *testing.T) {
          h := server.Default()
          h.GET("{{$MethodInfo.Path}}", {{$MethodInfo.Name}})
          w := ut.PerformRequest(h.Engine, "{{$MethodInfo.HTTPMethod}}", "{{$MethodInfo.Path}}", &ut.Body{Body: bytes.NewBufferString(""), Len: 1},
          ut.Header{})
          resp := w.Result()
          assert.DeepEqual(t, 201, resp.StatusCode())
          assert.DeepEqual(t, "", string(resp.Body()))
          // todo edit your unit test.
      }
      {{end}}