layouts:
  - path: handler.go
    delims:
      - "{{"
      - "}}"
    body: |-
      {{$OutDirs := GetUniqueHandlerOutDir .Methods}}
      package {{.PackageName}}
      import (
          "context"

          "github.com/cloudwego/hertz/pkg/app"
          "github.com/cloudwego/hertz/pkg/protocol/consts"
      
      {{- range $k, $v := .Imports}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
      {{- range $_, $OutDir := $OutDirs}}
          {{if eq $OutDir "" -}}
          "{{$.ProjPackage}}/biz/service"
          {{- else -}}
          "{{$.ProjPackage}}/biz/service/{{$OutDir}}"
          {{- end -}}
      {{- end}}
          "{{$.ProjPackage}}/pkg/httputil"
      )
      {{range $_, $MethodInfo := .Methods}}
      {{$MethodInfo.Comment}}
      func {{$MethodInfo.Name}}(ctx context.Context, c *app.RequestContext) {
          var req {{$MethodInfo.RequestTypeName}}
          resp := new({{$MethodInfo.ReturnTypeName}})
          if err := c.BindAndValidate(&req); err != nil {
              resp.Code = -1
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, consts.StatusBadRequest, resp)
              return
          }
          {{if eq $MethodInfo.OutputDir "" -}}
          err := service.New{{$MethodInfo.Name}}Service(ctx, c).Run(&req, resp)
          {{else}}
          err := {{$MethodInfo.OutputDir}}.New{{$MethodInfo.Name}}Service(ctx, c).Run(&req, resp)
          {{end}}
          if err != nil {
              resp.Code = int32(err.ErrCode())
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, err.StatusCode(), resp)
              return
          }
          httputil.SendResponse(ctx, c, consts.StatusOK, resp)
      }
      {{end}}
    update_behavior:
      import_tpl:
        - |-
          {{$OutDirs := GetUniqueHandlerOutDir .Methods}}
          {{- range $_, $OutDir := $OutDirs}}
            {{if eq $OutDir "" -}}
              "{{$.ProjPackage}}/biz/service"
            {{- else -}}
              "{{$.ProjPackage}}/biz/service/{{$OutDir}}"
            {{end}}
          {{- end}}
  - path: handler_single.go
    body: |+
      {{.Comment}}
      func {{.Name}}(ctx context.Context, c *app.RequestContext) {
          {{if ne .RequestTypeName "" -}}
          var req {{.RequestTypeName}}
          resp := new({{.ReturnTypeName}})
          if err := c.BindAndValidate(&req); err != nil {
              resp.Code = -1
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, consts.StatusBadRequest, resp)
              return
          }
          {{end}}
          {{if eq .OutputDir "" -}}
          err := service.New{{.Name}}Service(ctx, c).Run(&req, resp)
          {{else}}
          err := {{.OutputDir}}.New{{.Name}}Service(ctx, c).Run(&req, resp)
          {{end}}
          if err != nil {
              resp.Code = int32(err.ErrCode())
              resp.Message = err.Error()
              httputil.SendResponse(ctx, c, err.StatusCode(), resp)
              return
          }
          httputil.SendResponse(ctx, c, consts.StatusOK, resp)
      }
  - path: "{{.HandlerDir}}/{{.GenPackage}}/{{ToSnakeCase .ServiceName}}_test.go"
    loop_service: true
    update_behavior:
      type: "append"
      append_key: "method"
      insert_key: "Test{{$.Name}}"
      append_tpl: |-
        func Test{{.Name}}(t *testing.T) {
            h := server.Default()
            h.GET("{{.Path}}", {{.Name}})
            w := ut.PerformRequest(h.Engine, "{{.HTTPMethod}}", "{{.Path}}", &ut.Body{Body: bytes.NewBufferString(""), Len: 1},
            ut.Header{})
            resp := w.Result()
            assert.DeepEqual(t, 201, resp.StatusCode())
            assert.DeepEqual(t, "", string(resp.Body()))
            // todo edit your unit test.
        }
    body: |-
      package {{.FilePackage}}
      import (
          "bytes"
          "testing"
          "github.com/cloudwego/hertz/pkg/app/server"
          "github.com/cloudwego/hertz/pkg/common/test/assert"
          "github.com/cloudwego/hertz/pkg/common/ut"
      )
      {{range $_, $MethodInfo := $.Methods}}
      func Test{{$MethodInfo.Name}}(t *testing.T) {
          h := server.Default()
          h.GET("{{$MethodInfo.Path}}", {{$MethodInfo.Name}})
          w := ut.PerformRequest(h.Engine, "{{$MethodInfo.HTTPMethod}}", "{{$MethodInfo.Path}}", &ut.Body{Body: bytes.NewBufferString(""), Len: 1},
          ut.Header{})
          resp := w.Result()
          assert.DeepEqual(t, 201, resp.StatusCode())
          assert.DeepEqual(t, "", string(resp.Body()))
          // todo edit your unit test.
      }
      {{end}}
  - path: "biz/service/{{.HandlerGenPath}}/{{ToSnakeCase .MethodName}}.go"
    loop_method: true
    update_behavior:
      type: "skip"
    body: |-
      package {{.FilePackage}}
      import (
          "context"
          "github.com/cloudwego/hertz/pkg/app"
      {{- range $k, $v := .Models}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
          "meetplan/pkg/errno"
      )
      type {{.Name}}Service struct {
          RequestContext  *app.RequestContext
          Context         context.Context
      }
      
      func New{{.Name}}Service(ctx context.Context, RequestContext *app.RequestContext) *{{.Name}}Service {
          return &{{.Name}}Service{RequestContext: RequestContext, Context: ctx}
      }
      
      // Run req should not be nil and resp should not be nil
      func (h *{{.Name}}Service) Run(req *{{.RequestTypeName}}, resp *{{.ReturnTypeName}}) (err *errno.Err) {
          defer func() {
              if e := recover(); e != nil {
                  err = errno.NewInternalErr("panic in CreateFriendLinkService.Run")
              }
          }()
          if resp == nil{
              resp = new({{.ReturnTypeName}})
          }
          // todo edit your code
          return
      }
  - path: "biz/service/{{.HandlerGenPath}}/{{ToSnakeCase .MethodName}}_test.go"
    loop_method: true
    update_behavior:
      type: "skip"
    body: |-
      package {{.FilePackage}}
      import (
          "context"
          "testing"
          "github.com/cloudwego/hertz/pkg/app"
          "github.com/cloudwego/hertz/pkg/common/test/assert"
      {{- range $k, $v := .Models}}
          {{$k}} "{{$v.Package}}"
      {{- end}}
      )
      func Test{{.Name}}Service_Run(t *testing.T) {
          ctx := context.Background()
          c := app.NewContext(1)
          s := New{{.Name}}Service(ctx, c)
          // init req and assert value
          req := &{{.RequestTypeName}}{}
          resp := &{{.ReturnTypeName}}{}
          err := s.Run(req, resp)
          assert.DeepEqual(t, nil, resp)
          assert.DeepEqual(t, nil, err)
          // todo edit your unit test.
      }
  - path: "pkg/errno/errno.go"
    update_behavior:
      type: "skip"
    body: |-
      package errno

      import (
      	"bytes"
      	"errors"
      	"net/http"
      	"runtime"
      	"strconv"
      )

      type Err struct {
      	err        error
      	errCode    int
      	statusCode int

      	pcs        []uintptr
      	stackTrace string
      }

      func (e *Err) Error() string {
      	return e.err.Error()
      }

      func (e *Err) Unwrap() error {
      	return e.err
      }

      func (e *Err) StatusCode() int {
      	return e.statusCode
      }

      func (e *Err) ErrCode() int {
      	return e.errCode
      }

      func (e *Err) SetErrCode(errCode int) *Err {
      	e.errCode = errCode
      	return e
      }

      func (e *Err) StackTrace() string {
      	if len(e.stackTrace) != 0 {
      		return e.stackTrace
      	}
      	buf := bytes.NewBufferString("Stack Trace:")
      	if len(e.pcs) != 0 {
      		frame := runtime.CallersFrames(e.pcs)
      		for {
      			frame, more := frame.Next()
      			if !more {
      				break
      			}
      			buf.WriteByte('\n')
      			buf.WriteString(frame.Function)
      			buf.WriteByte('\n')
      			buf.WriteByte('\t')
      			buf.WriteString(frame.File)
      			buf.WriteByte(':')
      			buf.WriteString(strconv.Itoa(frame.Line))
      		}
      	}
      	if ierr, ok := e.err.(interface{ StackTrace() string }); ok {
      		buf.WriteByte('\n')
      		buf.WriteString(ierr.StackTrace())
      	} else if ierr, ok := e.err.(*Err); ok {
      		buf.WriteByte('\n')
      		buf.WriteString(ierr.StackTrace())
      	}
      	e.stackTrace = buf.String()
      	return e.stackTrace
      }

      func ToInternalErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusInternalServerError, pcs: callers(), errCode: -1}
      }

      func NewInternalErr(msg string) *Err {
      	return ToInternalErr(errors.New(msg))
      }

      func ToValidationErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusBadRequest, pcs: callers(), errCode: -1}
      }

      func NewValidationErr(msg string) *Err {
      	return ToValidationErr(errors.New(msg))
      }

      func ToPermissionErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusForbidden, pcs: callers(), errCode: -1}
      }

      func NewPermissionErr(msg string) *Err {
      	return ToPermissionErr(errors.New(msg))
      }

      func ToNotFoundErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusNotFound, pcs: callers(), errCode: -1}
      }

      func NewNotFoundErr(msg string) *Err {
      	return ToNotFoundErr(errors.New(msg))
      }

      func ToAuthenticationErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusUnauthorized, pcs: callers(), errCode: -1}
      }

      func NewAuthenticationErr(msg string) *Err {
      	return ToAuthenticationErr(errors.New(msg))
      }

      func ToDependencyErr(err error) *Err {
      	if err == nil {
      		return nil
      	}
      	return &Err{err: err, statusCode: http.StatusFailedDependency, pcs: callers(), errCode: -1}
      }

      func NewDependencyErr(msg string) *Err {
      	return ToDependencyErr(errors.New(msg))
      }

      func callers() []uintptr {
      	var pcs [64]uintptr
      	n := runtime.Callers(3, pcs[:])
      	return pcs[:n]
      }

  - path: "pkg/httputil/resp.go"
    update_behavior:
      type: "skip"
    body: |-
      package httputil

      import (
          "context"

          "github.com/cloudwego/hertz/pkg/app"         

          "{{.GoModule}}/pkg/bytesconv"
      )

      func SendResponse(ctx context.Context, c *app.RequestContext, code int, resp any) {
          if bytesconv.B2s(c.ContentType()) == "application/x-protobuf" {
              c.ProtoBuf(code, resp)
          } else {
              c.JSON(code, resp)
          }
      }
  - path: "pkg/bytesconv/bytesconv.go"
    update_behavior:
      type: "skip"
    body: |-
      package bytesconv

      import (
          "reflect"
          "unsafe"
      )

      // B2s converts byte slice to a string without memory allocation.
      // See https://groups.google.com/forum/#!msg/Golang-Nuts/ENgbUzYvCuU/90yGx7GUAgAJ .
      //
      // Note it may break if string and/or slice header will change
      // in the future go versions.
      func B2s(b []byte) string {
          /* #nosec G103 */
          return *(*string)(unsafe.Pointer(&b))
      }

      // S2b converts string to a byte slice without memory allocation.
      //
      // Note it may break if string and/or slice header will change
      // in the future go versions.
      func S2b(s string) (b []byte) {
          /* #nosec G103 */
          bh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
          /* #nosec G103 */
          sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
          bh.Data = sh.Data
          bh.Len = sh.Len
          bh.Cap = sh.Len
          return b
      }
  - path: config/config.go
    update_behavior:
      type: "skip"
    body: |-
      package config
      import (
          "os"
          "path/filepath"
          "sync"
          "github.com/cloudwego/hertz/pkg/common/hlog"
          "github.com/kr/pretty"
          "gopkg.in/validator.v2"
          "gopkg.in/yaml.v3"
      )
      var (
          conf *Config
          once sync.Once
      )
      type Config struct {
          Env string
          Hertz Hertz `yaml:"hertz"`
        MySQL MySQL `yaml:"mysql"`
        Redis Redis `yaml:"redis"`
      }
      type MySQL struct {
          DSN string `yaml:"dsn"`
      }
      type Redis struct {
          Address  string `yaml:"address"`
          Password string `yaml:"password"`
        Username string `yaml:"username"`
        DB       int    `yaml:"db"`
      }
      type Hertz struct {
          Address       string `yaml:"address"`
          EnablePprof   bool   `yaml:"enable_pprof"`
          LogLevel      string `yaml:"log_level"`
          LogFileName   string `yaml:"log_file_name"`
          LogMaxSize    int    `yaml:"log_max_size"`
          LogMaxBackups int    `yaml:"log_max_backups"`
          LogMaxAge     int    `yaml:"log_max_age"`
      }
      // GetConf gets configuration instance
      func GetConf() *Config {
          once.Do(initConf)
          return conf
      }
      func initConf() {
          prefix := "conf"
          confFileRelPath := filepath.Join(prefix, filepath.Join(GetEnv(), "conf.yaml"))
          content, err := os.ReadFile(confFileRelPath)
          if err != nil {
              panic(err)
          }
          conf = new(Config)
          err = yaml.Unmarshal(content, conf)
          if err != nil {
              hlog.Error("parse yaml error - %v", err)
              panic(err)
          }
          if err := validator.Validate(conf); err != nil {
              hlog.Error("validate config error - %v", err)
              panic(err)
          }
          conf.Env = GetEnv()
          pretty.Printf("%+v\n", conf)
      }
      func GetEnv() string {
          e := os.Getenv("GO_ENV")
          if len(e) == 0 {
              return "dev"
          }
          return e
      }
      func LogLevel() hlog.Level {
          level := GetConf().Hertz.LogLevel
          switch level {
          case "trace":
              return hlog.LevelTrace
          case "debug":
              return hlog.LevelDebug
          case "info":
              return hlog.LevelInfo
          case "notice":
              return hlog.LevelNotice
          case "warn":
              return hlog.LevelWarn
          case "error":
              return hlog.LevelError
          case "fatal":
              return hlog.LevelFatal
          default:
              return hlog.LevelInfo
          }
      }
  - path: config/dev/conf.yaml
    update_behavior:
      type: "skip"
    body: |-
      hertz:
        address: ":8080"
        enable_pprof: true
        log_level: info
        log_file_name: "log/hertz.log"
        log_max_size: 10
        log_max_age: 3
        log_max_backups: 50
      mysql:
        dsn: "gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&parseTime=True&loc=Local"
      redis:
        address: "127.0.0.1:6379"
        username: ""
        password: ""
        db: 0
  - path: biz/dal/init.go
    update_behavior:
      type: "skip"
    body: |-
      package dal
      import (
          "{{.GoModule}}/biz/dal/mysql"
          "{{.GoModule}}/biz/dal/redis"
      )
      
      func Init() {
          redis.Init()
          mysql.Init()
      }
      
      func Close() {
          redis.Close()
          mysql.Close()
      }
  - path: biz/dal/mysql/init.go
    update_behavior:
      type: "skip"
    body: |-
      package mysql
      import (
          "fmt"
          "{{.GoModule}}/config"
      
          "gorm.io/driver/mysql"
          "gorm.io/gorm"
      )
      var (
        DB  *gorm.DB
        err error
      )
      func Init() {
          DB, err = gorm.Open(mysql.Open(config.GetConf().MySQL.DSN),
              &gorm.Config{
                  PrepareStmt:            true,
                  SkipDefaultTransaction: true,
              },
          )
          if err != nil {
              panic(err)
          }
      }
      
      func Close() {
      	sqlDB, err := DB.DB()
      	if err != nil {
      		fmt.Printf("get sqlDB error - %v\n", err)
      		return
      	}
      	if err := sqlDB.Close(); err != nil {
      		fmt.Printf("close sqlDB error - %v\n", err)
      		return
      	}
      }

  - path: biz/dal/redis/init.go
    update_behavior:
      type: "skip"
    body: |-
      package redis
      import (
          "fmt"
          "context"
          
          "{{.GoModule}}/config"
          
          "github.com/redis/go-redis/v9"
      )
      var RedisClient *redis.Client
      func Init() {
          RedisClient = redis.NewClient(&redis.Options{
              Addr:     config.GetConf().Redis.Address,
              Username: config.GetConf().Redis.Username,
              Password: config.GetConf().Redis.Password,
              DB:       config.GetConf().Redis.DB,
          })
          if err := RedisClient.Ping(context.Background()).Err(); err != nil {
              panic(err)
          }
      }
      func Close() {
      	err := RedisClient.Close()
      	if err != nil {
      		fmt.Printf("close redis error - %v\n", err)
      		return
      	}
      }

  - path: main.go
    update_behavior:
      type: "skip"
    body: |-
      // Code generated by hertz generator.
  
      package main
      
      import (
          "{{.GoModule}}/biz/dal"
          "{{.GoModule}}/config"
        
          "github.com/cloudwego/hertz/pkg/app/server"
          "github.com/hertz-contrib/cors"
          "github.com/hertz-contrib/logger/accesslog"
          "github.com/hertz-contrib/pprof"
          "github.com/hertz-contrib/requestid"
      )
      
      func main() {
          dal.Init()
          conf := config.GetConf()
          h := server.Default(server.WithHostPorts(conf.Hertz.Address))
          if conf.Hertz.EnablePprof {
              pprof.Register(h)
          }
          h.Use(accesslog.New(), cors.Default(), requestid.New())
          register(h)
          
          h.Spin()
          dal.Close()
      }

